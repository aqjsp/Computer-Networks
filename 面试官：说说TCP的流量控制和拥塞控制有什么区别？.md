# 百度面试官：说说TCP的流量控制和拥塞控制有什么区别？

在计算机网络的世界里，TCP（传输控制协议）无疑是最核心的协议之一。它为应用程序提供了可靠的、面向连接的数据传输服务。

然而，要实现这种可靠性与高效性，TCP必须巧妙地处理两个关键问题：**流量控制**和**拥塞控制**。

这两个机制虽然都旨在调节数据发送速率，但其目的、作用范围和实现原理却有着本质的区别。

本文将深入探讨TCP的流量控制和拥塞控制，剖析它们的内在机制与核心差异，旨在为读者提供一个全面而深入的理解。

## 1、TCP流量控制

流量控制的核心目标是防止发送方发送数据过快，导致接收方来不及处理而使接收缓冲区溢出，进而造成数据丢失。

这是一个点对点的机制，关注的是发送方与接收方之间的数据传输速率匹配问题，确保接收方有能力处理发送方的数据流。

##### 1.1、滑动窗口机制的精髓

TCP通过滑动窗口 机制实现流量控制。每个TCP连接的发送方和接收方都维护一个独立的滑动窗口。

接收方在TCP报文头部中包含一个接收窗口（Receive Window, `rwnd`） 字段，用于告知发送方自己当前可接收的数据量大小。这个`rwnd`值动态反映了接收方应用程序处理数据的速度和其缓冲区剩余空间的大小。

发送方则根据接收方通告的`rwnd`来调整自己的发送窗口（Send Window） 大小，确保不会超出接收方的处理能力。

具体来说，发送方维护的发送窗口由以下几个关键变量决定：
*   `LastByteSent`：已发送的最后一个字节的序号。
*   `LastByteAcked`：已收到确认的最后一个字节的序号。
*   `SendWindow`：发送方当前允许发送的最大字节数，其上限由`rwnd`和`cwnd`共同决定。

接收方维护的接收窗口则由：
*   `NextByteExpected`：期望收到的下一个字节的序号。
*   `LastByteRcvd`：已收到的最后一个字节的序号。
*   `ReceiveWindow`：接收方当前可接收的最大字节数，即接收缓冲区剩余空间。

发送方的有效发送窗口大小为 `min(rwnd, cwnd)`。当`rwnd`为0时，发送方会停止发送数据，直到接收方通告一个非零的窗口值。

![TCP流量控制滑动窗口示意图](https://cdn.jsdelivr.net/gh/aqjsp/photos/CClgRvyDTiqYBrPg.png)

##### 1.2、流量控制中的挑战与解决方案

###### 1.2.1、零窗口探测（Zero Window Probe, ZWP）与持续计时器（Persistent Timer）

当接收方通告`rwnd`为0后，发送方会停止发送数据。如果接收方后续的非零窗口更新报文在网络中丢失，发送方将永远等待，接收方也永远收不到数据，从而形成死锁。

为解决此问题，TCP引入了持续计时器。当发送方收到零窗口通知时，会启动该计时器。计时器超时后，发送方会发送一个零窗口探测报文段（ZWP），这是一个仅携带一个字节数据的特殊报文，其目的是触发接收方发送一个ACK报文，其中包含当前的窗口值。

接收方收到ZWP后，会回复当前的窗口值，从而打破死锁僵局。

###### 1.2.2、糊涂窗口综合症（Silly Window Syndrome, SWS）

SWS是指当发送方或接收方处理数据不及时，导致每次只发送或接收少量数据，使得有效数据相对于TCP头部信息比例过小，传输效率低下。

例如，接收方应用每次只从缓冲区取走少量数据，导致`rwnd`每次只增加很小的值，发送方就只能发送很小的报文段。

这就像“一滴水一滴水地传输”，造成大量的网络开销和低效。

为避免SWS，通常采用以下策略：

* 接收方： 不通告过小的窗口值，通常等到窗口增加到最大报文段（MSS）大小或接收缓冲区一半时才通告。

* 发送方： 采用Nagle算法，将小数据包累积起来，直到达到MSS大小或收到前一个数据包的ACK后才发送。

  Nagle算法通过延迟发送小数据包，有效减少了网络中传输的小报文数量，提高了网络利用率。然而，Nagle算法有时会与延迟ACK机制（接收方等待一段时间再发送ACK）产生冲突，导致传输延迟增加，此时可以通过`TCP_NODELAY`选项禁用Nagle算法。

###### 1.2.3、窗口扩大选项（Window Scale Option）

TCP头部中的窗口字段只有16位，最大只能表示65535字节（64KB）的接收窗口。

在高速网络环境下，例如千兆以太网甚至万兆网络中，64KB的窗口大小远远不足以充分利用带宽，尤其是在长距离高延迟链路上（即“长肥网络”）。

为了解决这一限制，RFC 1323引入了窗口扩大选项，允许TCP在三次握手时协商一个窗口扩大因子。这个因子可以将16位窗口值左移，从而支持最大1GB甚至更大的接收窗口。

在Linux系统中，可以通过`net.ipv4.tcp_window_scaling`参数控制此功能，默认通常是开启的 [3]。

## 2、TCP拥塞控制：全局网络的健康卫士

拥塞控制（Congestion Control） 的核心目标是防止过多的数据注入到网络中，导致网络中的路由器或链路过载，从而避免整个网络的性能下降甚至崩溃。

这是一个全局性（Global） 的机制，关注的是整个网络的负载情况，而非仅仅是端系统之间的匹配。它通过动态调整发送方的发送速率，以适应网络的实际承载能力。

##### 2.1、拥塞窗口（`cwnd`）与发送窗口

发送方通过维护一个拥塞窗口（Congestion Window, `cwnd`） 来限制发送速率。`cwnd`的大小取决于发送方对网络拥塞程度的估计，并会动态调整。

发送方的实际有效发送窗口大小是`min(rwnd, cwnd)`。

也就是说，即使接收方有很大的接收能力（`rwnd`很大），如果网络出现拥塞（`cwnd`很小），发送方也必须限制其发送速率，以避免加剧网络拥塞。

##### 2.2、核心拥塞控制算法：TCP的四大基石

TCP的拥塞控制主要包含四种经典算法：慢开始（Slow Start）、拥塞避免（Congestion Avoidance）、快重传（Fast Retransmit）和快恢复（Fast Recovery）。

这些算法协同工作，共同构成了TCP拥塞控制的基石。

![TCP拥塞控制算法流程图](https://cdn.jsdelivr.net/gh/aqjsp/photos/yshNmsvVvNujhMto.png)

###### 2.2.1、慢开始（Slow Start）

慢开始算法是TCP连接建立后或发生严重丢包（如超时重传）后使用的初始阶段。

其核心思想是：**先探测，后加速**。

当TCP连接建立时，`cwnd`会被初始化为一个较小的值，通常是1个MSS（Maximum Segment Size，最大报文段大小）。

发送方每收到一个ACK，`cwnd`就增加1个MSS。

由于每个ACK通常确认一个MSS的数据，这意味着每经过一个RTT（Round-Trip Time，往返时间），`cwnd`就会翻倍，呈现**指数级增长**。

例如，如果初始`cwnd`为1 MSS，则在第一个RTT后变为2 MSS，第二个RTT后变为4 MSS，以此类推。

这种机制旨在快速探测网络的可用带宽，但又避免一开始就向网络注入大量数据，从而避免在连接初期就造成拥塞。

慢开始阶段的特点是`cwnd`呈指数增长，增长速度非常快，直到达到慢开始门限`ssthresh` [5]。

###### 2.2.2、慢开始门限（`ssthresh`）

为了防止`cwnd`无限指数增长导致拥塞，TCP引入了慢开始门限（Slow Start Threshold, `ssthresh`）。

`ssthresh`是一个阈值，当`cwnd`达到`ssthresh`时，慢开始阶段结束，进入拥塞避免阶段。

`ssthresh`的初始值通常较大（如65535字节），但当网络发生拥塞时（例如发生丢包），`ssthresh`会被动态调整为当前`cwnd`的一半，作为下一次慢开始的上限。

这个机制确保了在网络拥塞后，TCP不会再次以过快的速度将大量数据注入网络 [5]。

###### 2.2.3、拥塞避免（Congestion Avoidance）

当`cwnd`达到或超过`ssthresh`时，TCP进入拥塞避免阶段。

此时，TCP认为网络可能已经接近其承载能力，因此`cwnd`的增长方式变得更加保守。

在拥塞避免阶段，`cwnd`的增长变为**线性**：每经过一个RTT，`cwnd`只增加1个MSS（或更精确地说，每收到一个ACK，`cwnd`增加`MSS * (MSS / cwnd)`，这样在一个RTT内，`cwnd`大约增加1个MSS）。

这种缓慢增长的方式可以避免过快地增加网络负载，从而维持网络的稳定，逐步探测网络的更大容量，直至再次发生拥塞。

###### 2.2.4、拥塞发生与恢复

当网络出现丢包时，TCP会认为网络发生了拥塞。丢包的判断依据主要有两种，对应两种不同的拥塞恢复策略：

**超时重传（Retransmission Timeout, RTO）**

如果发送方在设定的重传时间内没有收到某个数据段的ACK，就会触发超时重传。

这通常意味着网络状况非常糟糕，可能发生了严重的拥塞，甚至网络路径中断。

此时，TCP会采取较为保守的策略：将`ssthresh`减半（设置为当前`cwnd`的一半），并将`cwnd`重置为1个MSS，然后重新进入慢开始阶段。

这种“回到原点”的策略是为了彻底缓解网络拥塞。

**快速重传（Fast Retransmit）与快速恢复（Fast Recovery）**

如果发送方连续收到三个重复的ACK（Duplicate ACK），这表明某个数据段丢失，但后续数据段已到达接收方，说明网络并非完全瘫痪，只是局部丢包。

在这种情况下，TCP不等待RTO超时，立即重传丢失的报文段。这被称为**快速重传**。

同时，`ssthresh`减半（设置为当前`cwnd`的一半），`cwnd`设置为`ssthresh`的值，并进入**快速恢复**阶段。

在快速恢复阶段，每收到一个重复ACK，`cwnd`增加1个MSS（因为这表明网络仍在传输数据，且有数据包离开网络）；当收到新数据的ACK（确认了所有在快速重传之前发送的数据）时，`cwnd`设置为`ssthresh`，然后进入拥塞避免阶段。

这种机制避免了超时重传导致的`cwnd`骤降和漫长的慢开始过程，提高了恢复效率，更适用于轻度拥塞，能够更快地恢复数据传输。

##### 2.3、现代拥塞控制算法的演进

除了经典的Tahoe（仅包含慢开始和拥塞避免，超时重传后`cwnd`置1）和Reno（引入快重传和快恢复）算法，现代TCP还发展出多种更先进的拥塞控制算法，以适应不同的网络环境和需求。

例如：

*   SACK（Selective Acknowledgment）： 选择性确认，允许接收方告知发送方哪些非连续的数据段已收到，从而使发送方只重传真正丢失的数据段，避免不必要的重传，提高了重传效率。
*   D-SACK（Duplicate SACK）： 扩展SACK，用于告知发送方哪些数据段被重复接收，有助于发送方区分是丢包还是乱序，进一步优化重传策略，尤其在处理乱序报文时非常有用 [6]。
*   BIC-TCP、CUBIC、Vegas、BBR： 这些是更现代的拥塞控制算法，它们通过更复杂的机制（如基于延迟、带宽测量等）来预测和避免拥塞，旨在在提高吞吐量的同时降低延迟。例如，Google的BBR（Bottleneck Bandwidth and Round-trip propagation time） 算法，通过持续测量网络的瓶颈带宽和往返传播时间来估计网络的实际容量，从而更精确地控制发送速率，在特定场景下（如高带宽、高延迟网络）表现出色，显著提升了吞吐量和降低了延迟。

## 3、流量控制与拥塞控制的区别

尽管流量控制和拥塞控制都涉及对发送速率的调节，但它们解决的问题、作用范围和关注点截然不同。理解这些差异是深入掌握TCP协议的关键。

下表总结了它们的主要区别：

| 特性     | 流量控制 (Flow Control)                | 拥塞控制 (Congestion Control)                           |
| :------- | :------------------------------------- | :------------------------------------------------------ |
| 目的     | 调节发送方速率，防止接收方缓冲区溢出。 | 调节发送方速率，防止网络拥塞。                          |
| 作用范围 | 点对点 (发送方与接收方之间)。          | 全局性 (涉及所有主机、路由器，整个网络)。               |
| 关注对象 | 接收方的接收能力 (接收缓冲区大小)。    | 网络的传输能力 (路由器队列、链路带宽、延迟、丢包率等)。 |
| 主要变量 | 接收窗口 (`rwnd`)。                    | 拥塞窗口 (`cwnd`)。                                     |
| 控制依据 | 接收方在TCP报文头部中通告的窗口大小。  | 通过探测网络状况（丢包、延迟、RTT变化等）动态调整。     |
| 触发机制 | 接收方缓冲区状态变化。                 | 网络拥塞（超时、重复ACK）。                             |
| 影响因素 | 接收方处理速度、缓冲区大小。           | 路由器负载、链路带宽、网络拓扑结构、数据包丢失率。      |

## 4、总结

TCP的流量控制和拥塞控制是确保网络通信可靠、高效的“双保险”。

流量控制着眼于微观的端系统之间协调，确保接收方有能力处理发送方的数据，避免接收方过载；

而拥塞控制则着眼于宏观的网络整体健康，避免网络因过载而崩溃。

两者协同工作，共同决定了发送方的实际发送速率，即`min(rwnd, cwnd)`，以适应接收方的处理能力和网络的承载能力，从而实现TCP连接的稳定、高效数据传输。

